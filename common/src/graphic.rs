use uefi::{boot::ScopedProtocol, proto::console::gop::GraphicsOutput};

use crate::error::Result;

#[derive(Debug, Clone, PartialEq)]
pub enum GraphicError {
    UnsupportedPixelFormat,
}

impl GraphicError {
    pub fn msg(&self) -> &'static str {
        match *self {
            Self::UnsupportedPixelFormat => "Unsupported pixel format.",
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub enum PixelFormat {
    Rgb,
    Bgr,
}

impl PixelFormat {
    pub fn from_gop_pixel_format_type(
        pixel_format: &uefi::proto::console::gop::PixelFormat,
    ) -> Result<Self> {
        match *pixel_format {
            uefi::proto::console::gop::PixelFormat::Bgr => Ok(Self::Bgr),
            uefi::proto::console::gop::PixelFormat::Rgb => Ok(Self::Rgb),
            _ => return Err(GraphicError::UnsupportedPixelFormat.into()),
        }
    }
}

pub struct GraphicInfo {
    pub width: usize,
    pub height: usize,
    pub stride: usize,
    pub bytes_per_pixel: usize,
    pub pixel_format: PixelFormat,
    pub frame_buffer_addr: u64,
    pub size: usize,
}

impl GraphicInfo {
    pub fn from_gop(gop: &mut ScopedProtocol<GraphicsOutput>) -> Result<Self> {
        let current_mode_info = gop.current_mode_info();
        let resolution = current_mode_info.resolution();
        let mut frame_buffer = gop.frame_buffer();

        let width = resolution.0;
        let height = resolution.1;
        let stride = current_mode_info.stride();
        // let bytes_per_pixel = frame_buffer.size() / width * height; THIS CALCULATION IS INCORRECT!!!.
        let bytes_per_pixel = 4;
        let pixel_format =
            PixelFormat::from_gop_pixel_format_type(&current_mode_info.pixel_format())?;
        let frame_buffer_addr = frame_buffer.as_mut_ptr() as u64;
        let size = frame_buffer.size();

        Ok(Self {
            width,
            height,
            stride,
            bytes_per_pixel,
            pixel_format,
            frame_buffer_addr,
            size,
        })
    }
}

// impl From<bootloader_api::info::FrameBuffer> for GraphicInfo {
//     fn from(framebuf: bootloader_api::info::FrameBuffer) -> Self {
//         let info = framebuf.info();
//         Self {
//             width: info.width,
//             height: info.height,
//             bytes_per_pixel: info.bytes_per_pixel,
//             stride: info.stride,
//             pixel_format: match info.pixel_format {
//                 bootloader_api::info::PixelFormat::Rgb => PixelFormat::Rgb,
//                 bootloader_api::info::PixelFormat::Bgr => PixelFormat::Bgr,
//                 _ => panic!(
//                     "Unsupported pixel format error. \
//                     As the kernel using graphic information provided by bootloader_api crate, \
//                     Maizono's GraphicInfo structure must be generated by converting bootloader_api's information to it. \
//                     Because converting process is implemented as From trait implementation, it's impossible to return errors so, \
//                     the kernel panicked"
//                 ),
//             },
//             framebuf_size: info.byte_len,
//             framebuf_addr: framebuf.into_buffer().as_mut_ptr() as u64,
//         }
//     }
// }

#[derive(Clone, Copy, Debug)]
pub struct Pixel(u32);

impl Pixel {
    pub fn new() -> Self {
        Self(0x00000000)
    }

    pub fn rgb(r: u8, g: u8, b: u8) -> Self {
        Self(u32::from_be_bytes([r, g, b, 0x0]))
    }

    pub fn get(&self) -> u32 {
        self.0
    }

    pub fn bgr(&mut self) {
        let r = ((self.0 & 0xff000000) >> 0x18) as u8;
        let g = ((self.0 & 0xff0000) >> 0x10) as u8;
        let b = ((self.0 & 0xff00) >> 0x8) as u8;
        self.0 = u32::from_be_bytes([b, g, r, 0]);
    }

    pub fn le(&self) -> u32 {
        u32::from_be(self.0)
    }
}

impl From<u32> for Pixel {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

impl From<RgbColor> for Pixel {
    fn from(value: RgbColor) -> Self {
        Self(value.get() & 0xFFFFFF00)
    }
}

#[derive(Clone, Copy, Debug)]
pub struct RgbColor(u32);

impl RgbColor {
    pub fn new() -> Self {
        Self(0x00000000)
    }

    pub fn rgb(r: u8, g: u8, b: u8) -> Self {
        Self(u32::from_be_bytes([r, g, b, 0x00]))
    }

    pub fn get(&self) -> u32 {
        self.0
    }

    pub fn to_bgr(&mut self) {
        let r = ((self.0 & 0xff000000) >> 0x18) as u8;
        let g = ((self.0 & 0xff0000) >> 0x10) as u8;
        let b = ((self.0 & 0xff00) >> 0x8) as u8;
        self.0 = u32::from_be_bytes([b, g, r, 0])
    }
}

impl From<u32> for RgbColor {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

impl From<Pixel> for RgbColor {
    fn from(value: Pixel) -> Self {
        Self(value.get() & 0xFFFFFF00)
    }
}
