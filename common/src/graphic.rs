use uefi::{boot::ScopedProtocol, proto::console::gop::GraphicsOutput};

use crate::error::Result;

#[derive(Debug, Clone, PartialEq)]
pub enum GraphicError {
    UnsupportedPixelFormat,
}

impl GraphicError {
    pub fn msg(&self) -> &'static str {
        match *self {
            Self::UnsupportedPixelFormat => "Unsupported pixel format.",
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub enum PixelFormat {
    Rgb,
    Bgr,
}

impl PixelFormat {
    pub fn from_gop_pixel_format_type(
        pixel_format: &uefi::proto::console::gop::PixelFormat,
    ) -> Result<Self> {
        match *pixel_format {
            uefi::proto::console::gop::PixelFormat::Bgr => Ok(Self::Bgr),
            uefi::proto::console::gop::PixelFormat::Rgb => Ok(Self::Rgb),
            _ => return Err(GraphicError::UnsupportedPixelFormat.into()),
        }
    }
}

#[derive(Clone, Debug)]
pub struct GraphicInfo {
    pub width: u64,
    pub height: u64,
    pub stride: usize,
    pub bytes_per_pixel: u64,
    pub pixel_format: PixelFormat,
    pub frame_buffer_addr: Option<u64>,
    pub frame_buffer_size: usize,
}

impl GraphicInfo {
    pub fn from_gop(gop: &mut ScopedProtocol<GraphicsOutput>) -> Result<Self> {
        let current_mode_info = gop.current_mode_info();
        let resolution = current_mode_info.resolution();
        let mut frame_buffer = gop.frame_buffer();

        let width = resolution.0 as u64;
        let height = resolution.1 as u64;
        let stride = current_mode_info.stride();
        let bytes_per_pixel = 4;
        let pixel_format =
            PixelFormat::from_gop_pixel_format_type(&current_mode_info.pixel_format())?;
        let frame_buffer_addr = frame_buffer.as_mut_ptr() as u64;
        let frame_buffer_size = frame_buffer.size();

        Ok(Self {
            width,
            height,
            stride,
            bytes_per_pixel,
            pixel_format,
            frame_buffer_addr: Some(frame_buffer_addr),
            frame_buffer_size,
        })
    }

    pub const fn new_empty() -> Self {
        Self {
            width: 0,
            height: 0,
            stride: 0,
            bytes_per_pixel: 0,
            pixel_format: PixelFormat::Bgr,
            frame_buffer_addr: None,
            frame_buffer_size: 0,
        }
    }
}

// impl From<bootloader_api::info::FrameBuffer> for GraphicInfo {
//     fn from(framebuf: bootloader_api::info::FrameBuffer) -> Self {
//         let info = framebuf.info();
//         Self {
//             width: info.width,
//             height: info.height,
//             bytes_per_pixel: info.bytes_per_pixel,
//             stride: info.stride,
//             pixel_format: match info.pixel_format {
//                 bootloader_api::info::PixelFormat::Rgb => PixelFormat::Rgb,
//                 bootloader_api::info::PixelFormat::Bgr => PixelFormat::Bgr,
//                 _ => panic!(
//                     "Unsupported pixel format error. \
//                     As the kernel using graphic information provided by bootloader_api crate, \
//                     Maizono's GraphicInfo structure must be generated by converting bootloader_api's information to it. \
//                     Because converting process is implemented as From trait implementation, it's impossible to return errors so, \
//                     the kernel panicked"
//                 ),
//             },
//             framebuf_size: info.byte_len,
//             framebuf_addr: framebuf.into_buffer().as_mut_ptr() as u64,
//         }
//     }
// }

// #[derive(Clone, Copy, Debug)]
// pub struct Pixel(u32);

// impl Pixel {
//     pub const fn new() -> Self {
//         Self(0x00000000)
//     }

//     pub fn rgb(r: u8, g: u8, b: u8) -> Self {
//         Self(u32::from_be_bytes([r, g, b, 0]))
//     }

//     pub fn get(&self) -> u32 {
//         self.0
//     }

//     pub fn bgr(&mut self) {
//         let r = ((self.0 & 0xff000000) >> 0x18) as u8;
//         let g = ((self.0 & 0xff0000) >> 0x10) as u8;
//         let b = ((self.0 & 0xff00) >> 0x8) as u8;
//         self.0 = u32::from_be_bytes([b, g, r, 0]);
//     }

//     pub fn le(&self) -> u32 {
//         u32::from_be(self.0)
//     }

//     pub const fn from(value: u32) -> Self {
//         Self(value)
//     }
// }

// impl From<u32> for Pixel {
//     fn from(value: u32) -> Self {
//         Self(value)
//     }
// }

// impl From<RgbColor> for Pixel {
//     fn from(value: RgbColor) -> Self {
//         Self(value.get() & 0xFFFFFF00)
//     }
// }

#[derive(Clone, Copy, Debug, PartialEq)]
// pub struct RgbColor(u32);
pub struct RgbColor {
    data: u32,
    pub is_transparent: bool,
}

impl RgbColor {
    pub const fn new() -> Self {
        Self {
            data: 0,
            is_transparent: false,
        }
    }

    pub const fn transparent() -> Self {
        Self {
            data: 0,
            is_transparent: true,
        }
    }

    pub const fn rgb(r: u8, g: u8, b: u8, is_t: bool) -> Self {
        Self {
            data: u32::from_be_bytes([r, g, b, 0x00]),
            is_transparent: is_t,
        }
    }

    pub const fn get(&self) -> u32 {
        self.data
    }

    pub const fn to_bgr(&mut self) {
        let r = ((self.data & 0xff000000) >> 0x18) as u8;
        let g = ((self.data & 0xff0000) >> 0x10) as u8;
        let b = ((self.data & 0xff00) >> 0x8) as u8;
        self.data = u32::from_be_bytes([b, g, r, 0])
    }

    pub const fn from(value: u32) -> Self {
        Self {
            data: value,
            is_transparent: false,
        }
    }

    pub fn le(&self) -> u32 {
        u32::from_be(self.data)
    }

    pub fn bgr(&mut self) {
        let r = ((self.data & 0xff000000) >> 0x18) as u8;
        let g = ((self.data & 0xff0000) >> 0x10) as u8;
        let b = ((self.data & 0xff00) >> 0x8) as u8;
        self.data = u32::from_be_bytes([b, g, r, 0]);
    }
}

// impl From<Pixel> for RgbColor {
//     fn from(value: Pixel) -> Self {
//         Self(value.get() & 0xFFFFFF00)
//     }
// }
