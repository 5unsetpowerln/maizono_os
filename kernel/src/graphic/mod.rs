pub mod console;
pub mod font;
pub mod framebuffer;

#[derive(Clone, Copy, Debug)]
pub enum PixelFormat {
    Rgb,
    Bgr,
}

pub struct GraphicInfo {
    pub width: usize,
    pub height: usize,
    pub bytes_per_pixel: usize,
    pub stride: usize,
    pub pixel_format: PixelFormat,
    pub framebuf_addr: u64,
    pub framebuf_size: usize,
}

impl From<bootloader_api::info::FrameBuffer> for GraphicInfo {
    fn from(framebuf: bootloader_api::info::FrameBuffer) -> Self {
        let info = framebuf.info();
        Self {
            width: info.width,
            height: info.height,
            bytes_per_pixel: info.bytes_per_pixel,
            stride: info.stride,
            pixel_format: match info.pixel_format {
                bootloader_api::info::PixelFormat::Rgb => PixelFormat::Rgb,
                bootloader_api::info::PixelFormat::Bgr => PixelFormat::Bgr,
                _ => panic!(
                    "Unsupported pixel format error. \
                    As the kernel using graphic information provided by bootloader_api crate, \
                    Maizono's GraphicInfo structure must be generated by converting bootloader_api's information to it. \
                    Because converting process is implemented as From trait implementation, it's impossible to return errors so, \
                    the kernel panicked"
                ),
            },
            framebuf_size: info.byte_len,
            framebuf_addr: framebuf.into_buffer().as_mut_ptr() as u64,
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct Pixel(u32);

impl Pixel {
    pub fn new() -> Self {
        Self(0x00000000)
    }

    pub fn rgb(r: u8, g: u8, b: u8) -> Self {
        Self(u32::from_be_bytes([r, g, b, 0]))
    }

    pub fn get(&self) -> u32 {
        self.0
    }

    pub fn bgr(&mut self) {
        let r = ((self.0 & 0xff000000) >> 0x18) as u8;
        let g = ((self.0 & 0xff0000) >> 0x10) as u8;
        let b = ((self.0 & 0xff00) >> 0x8) as u8;
        self.0 = u32::from_be_bytes([b, g, r, 0]);
    }

    pub fn le(&self) -> u32 {
        u32::from_be(self.0)
    }
}

impl From<u32> for Pixel {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

impl From<RgbColor> for Pixel {
    fn from(value: RgbColor) -> Self {
        Self(value.get() & 0xFFFFFF00)
    }
}

#[derive(Clone, Copy, Debug)]
pub struct RgbColor(u32);

impl RgbColor {
    pub fn new() -> Self {
        Self(0x00000000)
    }

    pub fn rgb(r: u8, g: u8, b: u8, a: u8) -> Self {
        Self(u32::from_be_bytes([r, g, b, a]))
    }

    pub fn get(&self) -> u32 {
        self.0
    }

    pub fn to_bgr(&mut self) {
        let r = ((self.0 & 0xff000000) >> 0x18) as u8;
        let g = ((self.0 & 0xff0000) >> 0x10) as u8;
        let b = ((self.0 & 0xff00) >> 0x8) as u8;
        self.0 = u32::from_be_bytes([b, g, r, 0])
    }
}

impl From<u32> for RgbColor {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

impl From<Pixel> for RgbColor {
    fn from(value: Pixel) -> Self {
        Self(value.get() & 0xFFFFFF00)
    }
}
